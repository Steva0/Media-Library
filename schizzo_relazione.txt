INTRODUZIONE
Abbiamo creato un software che permette la gestione di una libreria di contenuti multimediali quali album, film, serie TV, romanzi, audiolibri e eBook, con parametri solo in parte unici per tipo.
Dato un contenuto, è possibile selezionarlo per vederne i dati di base, ovvero quelli comuni a tutti i tipi di media. È quindi possibile effettuare una modifica rapida di tali informazioni, cancellare il contenuto oppure aprire una nuova schermata che permette una schermata di modifica che varia in base al tipo di contenuto. Si può premere due volte il tasto sinistro del mouse su un contenuto presentato tra i risultati per aprirne le informazioni.
È possibile effettuare una ricerca base, utilizzando solamente il titolo del contenuto cercato, in tempo reale. In alternativa si può aprire una schermata di ricerca avanzata che permette una ricerca con informazioni che variano in base al genere cercato.
Una libreria può quindi essere salvato in formato JSON/XML, deciso al momento del salvataggio.
Sono state impostate scorciatoie di tastiera per confermare una ricerca avanzata o cambiare schermata dalla ricerca avanzata a quella semplice.
Per quanto riguarda l'interfaccia grafica realizzata in Qt, è stato utilizzato uno `SlidingStackedWidget` (trovato su GitHub) per rendere più piacevole la presentazione. Il suo funzionamento è lo stesso di uno `StackedWidget` ma sono presenti dei metodi per la transizione delle schermate.
---------------------------
DESCRIZIONE DEL MODELLO
Il software è diviso in namespace che definiscono le separazioni logiche tra le classi.
Il namespace `media` contiene la definizione di tutte le classi che derivano da `Media`. Abbiamo definito un'interfaccia `IConstVisitor`, ampiamente utilizzata da altri namespace, dove generalmente si fa riferimento a un sottotipo di `Media` tramite puntatore. Non abbiamo implementato un `IVisitor` dal momento che non ci sembrava necessario.
La classe `Media` implementa l'interfaccia `IMedia`, ma abbiamo scelto di non renderla astratta: nella ricerca avanzata è stata nostra intenzione permettere la ricerca in base ai dati propri di ciascun media. Per effettuare quindi una ricerca avanzata tra tutti i tipi di `Media` abbiamo trovato conveniente utilizzare un `Media` concreto come filtro.
Per effettuare una ricerca avanzata è stata definito un metodo virtuale puro `bool filter(const media::Media &)` all'interno dell'interfaccia `IMedia`. L'implementazione prevede che sia necessario, ma non sufficiente, che il filtro passato come parametro sia un sottotipo della classe chiamante.
`IMedia` contiene metodi virtuali polimorfi quali `unique_ptr<Media> makePtr()`, che vuole clonare in modo polimorfo un `IMedia`, e `std::string displayType()`, che ritorna, come stringa, il tipo di un `IMedia`. Questo è stato utilizzato dall'interfaccia grafica per evitare la costruzione di visitor banali.
Da segnalare inoltre che la classe `AudioBook` deriva da `Novel`, che contiene il campo dati `int pages_` che fa riferimento al numero di pagine, ovviamente insensato per una classe per audiolibri. Abbiamo quindi riutilizzato la variabile per fare riferimento alla lunghezza dell'audiolibro in secondi.

All'interno del namespace `Memory` sono presenti due classi principali: `MediaContainer` e `Database`.
`Database` viene utilizzato dall'interfaccia grafica per accedere a `Database`, e si occupa di (de)serializzare in formato JSON/XML, a seconda dell'estensione del file aperto. Per quanto riguarda la serializzazione, una classe `Serializer` implementa un metodo statico `void serialize(const vector<const Media*>&, QFile&) e utilizza `MediaXMLVisitor` e `MediaJSONVisitor`, entrambe derivanti da `IConstMediaVisitor`.
Per composizione fa riferimento a un `MediaContainer` che contiene un array di vettori, uno per sottotipo di `Media`. All'interno di quest'altra classe è definita una `enum class Type` che associa a ciascun sottotipo di `Media` un indice di tale array. Si fa notare che, per via della struttura dell'enum, il primo vettore dell'array sarà sempre vuoto. Un'alternativa a cui avevamo pensato era stato utilizzare un vettore concreto per sottotipo di `Media`, e fare riferimento a ciascuno individualmente, ma ci era sembrato poco comodo l'accesso a un determinato sottotipo e comunque impediva in parte lo sfruttamento del polimorfismo. Un'altra possibilità sarebbe stata utilizzare un unico vettore di puntatori a `Media` generici, ma così facendo avremmo perso la possibilità di iterare su un singolo sottotipo di `Media`. Abbiamo quindi scelto una via di mezzo che, seppur meno scalabile, soddisfa le nostre necessità.
Abbiamo utilizzato `unique_ptr` per assicurarci la cancellazione dei `Media` alla distruzione di un `MediaContainer`. Infine, quando la parte grafica fa riferimento a un `Media`, questo viene clonato.
Infine, `MediaContainer` definisce una classe privata `MediaOpVisitor` come stratagemma per evitare la creazione di molteplici visitor.
---------------------------
POLIMORFISMO
Ci siamo assicurati di sfruttare il polimorfismo nelle interfacce con distruttori virtuali, anche se in realtà non è mai stato modificato dal momento che non è stato necessario utilizzare puntatori nella definizione dei campi dati dei sottotipi di `Media`.
Inoltre, come scritto in precedenza, il visitor pattern è stato utilizzato nella serializzazione di dati e internamente alla classe `MediaContainer` tramite `MediaOpVisitor`, che si occupa dell'inserimento dei `Media` all'interno del vettore corretto oppure di copiare i vettori contenti oggetti di appartenenza. In realtà avremmo potuto ??
Lo stesso pattern è stato utilizzato in abbondanza lato interfaccia grafica, in particolare per quanto riguarda la presentazione dei Media. Infatti il namespace `gui` non conosce mai il tipo concreto dei dati che ottiene, ma sia quando si visualizzano informazioni nel dettaglio, sia quanto si effettua una ricerca avanzata, i dati presentati abbiamo scelto dovessero variare in base al sottotipo. Per quanto riguarda invece la ricerca semplice non è mai stato effettuato alcun tipo di cast, e per l'indicazione del sottotipo di appartenenza si è fatto riferimento solamente al metodo virtuale `string displayType()` implementato da ciascun `Media`.
---------------------------
PERSISTENZA DEI DATI
Per la persistenza dei dati abbiamo, come richiesto, utilizzato il Framework Qt per la gestione di formati JSON e XML. Al momento del salvataggio di un database appena creato è possibile scegliere il formato di dal menu a tendina della finestra di popup per il salvataggio. Per quanto riguarda il file JSON, sono stati creati degli oggetti, uno per campo dato della classe che viene salvata. La costruzione del file XML è simmetrica. In sede di serializzazione vengono considerate solamente sottoclassi strette di `Media`.
---------------------------
FUNZIONALITÀ IMPLEMENTATE
È possibile:
	- creare, modificare e cancellare vari tipi di contenuti multimediali: libri, audiolibri, eBook, film, serie TV e album musicali;
	- salvare tali modifiche in formato JSON/XML e caricare gli stessi tipi di file;
	- effettuare un filtraggio di un contenuto, dati parametri di un altro contenuto;
Per quanto riguarda l'interfaccia grafica:
	- schermata iniziale per aprire e creare database JSON/XML;
	- schermata per ricerca semplice in tempo reale sulla base del solo titolo di un contenuto;
	- schermata per ricerca avanzata con parametri che variano in base al tipo di media cercato.
	- schermata per visualizzazione e modifica, unica per tipo di contenuto;
	- nella schermata di ricerca base è possibile visualizzare una preview ed effettuare modifica rapida su certi parametri;
	- barra del menu in alto permette l'apertura e chiusura, modifica e salvataggio di un database;
	- barra di stato in basso presenta informazioni in merito all'interfaccia grafica
	- scorciatoia di tastiera (invio per effettuare una ricerca avanzata).
---------------------------
RENDICONTAZIONE ORE
<schema>
Abbiamo riscontrato notevoli ritardi a causa di ricompilazioni continue che impiegavano tempo non trascurabile.
